import { Request, Response } from "express";

import { InputUserInterface, UserInterface } from "@src/interfaces";
import { UserService } from "@src/services";
import { UserConfirmationEnum } from "@src/enums";
import { SuccessResponse } from "@src/helpers";
import { emailTemplate } from "@src/template";

export class UserController {
    static async signUp(req: Request, res: Response): Promise<Response> {
        try {
            //const roleData = await role.findOne({ where: { name: "Admin" } });
        
            const userData = {
              email: req?.body ? req?.body?.email : "",
              //created_by: req.user.id,
              //role_id: roleData.id,
            };
        
            //check if admin name already exists
            // const adminNameExists = await userProfile.findOne({ 
            //   where: { 
            //     first_name: profileData.first_name,
            //     last_name: profileData.last_name
            //   } 
            // });
            // if (adminNameExists) {
            //   return res.status(400).json({ message: "Admin with this name already exists!" });
            // }
        
            // Generate verification token
            //const token = await userService.createUserVerificationToken(data.id);
            //const verificationLink = `${process.env.CMSURL}/email-verification/${token.token}`;
        
            // Send verification email
            // const mailOptions = {
            //   from: "no-reply@yourdomain.com",
            //   to: data.email,
            //   subject: "Account Verification",
            //   html: emailTemplate,
            // };
        
            // await sendEmail(mailOptions);

            // const key: string = `lambda/${req.body.jobKeyName}.json`,
            // object = await AwsS3.getObject(key),
            // transcription: AWSTranscriptionInformationInterface = JSON.parse(await object.Body!.transformToString()),
            // callSummary = transcription.ConversationCharacteristics.ContactSummary?.AutoGenerated?.OverallSummary.Content,
            // transcript = transcription.Transcript;

            // const transcribedDataExists = await new TranscriptionInformationService().findOne({ jobKeyName: req.body.jobKeyName }),
            //     transcribedData = await new TranscriptionInformationService().updateOne({
            //         id: transcribedDataExists.id,
            //         input: {
            //             targetLanguageCode: transcription.LanguageCode,
            //             sentiment: sentiment as SentimentEnum
            //         }
            //     });

            const userInput: InputUserInterface = req.body;
            let user: UserInterface;
            try {
              user = await new UserService().create({
                name: userInput.name,
                username: userInput.username,
                email: userInput.email,
                phoneNumber: userInput.phoneNumber,
                confirmationStatus: UserConfirmationEnum.CONFIRMED,
              });
            } catch (error) {
              user = await new UserService().findOne({ email: userInput.email });
            }

            return SuccessResponse.send({
              message: "User created successfully!",
              data: user,
            });
          } 
          catch (error) {
            console.error(error);
        
            //create error log
            // const errorLogData = {
            //   table: "users",
            //   type: "create",
            //   error_message: error.message,
            //   status_code: 500,
            //   status: "Internal Server Error",
            //   message: "An error occurred while creating an admin.",
            //   created_by: req.user.id,
            // };
            // await errorLogService.createErrorLog(errorLogData);
        
            return res.status(500).json({
              status: "Internal Server Error",
              status_code: 500,
              message: "An error occurred while creating the admin.",
              //error: error.message,
            });
          }
    }


}